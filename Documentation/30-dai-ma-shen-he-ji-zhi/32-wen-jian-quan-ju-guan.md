3.2 文件全局观
=========

原创 [小马儿2019](https://me.csdn.net/zhangmalong) 最后发布于2020-02-21 10:51:11 阅读数 65 收藏

发布于2020-02-21 10:51:11

文章标签： [嵌入式](https://so.csdn.net/so/search/s.do?q=嵌入式&t=blog) [c语言](https://so.csdn.net/so/search/s.do?q=c语言&t=blog) [程序设计](https://so.csdn.net/so/search/s.do?q=程序设计&t=blog)

[](http://creativecommons.org/licenses/by-sa/4.0/)版权声明：本文为博主原创文章，遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。

本文链接：[https://blog.csdn.net/zhangmalong/article/details/104423898](https://blog.csdn.net/zhangmalong/article/details/104423898)

3.2.1 从文档到程序
------------

我方向感比较强，去一个新地方之前，必须先简单研究一下地图，有个大致脉络，才不会晕头转向。同理，你让我冒然去阅读或审核一大堆代码，我会立马陷入细节中，晕头转向了。

我们人类的大脑擅长逻辑分析，擅长关联推理，擅长脉络架构，但唯独不擅长记忆，更难以同时关注多个对象。

很不巧，如果不加控制，大多数产品的代码都是粗暴的碎片化堆砌。缺个子函数，前面堆一个，但阅读时不会先读后面在跳前面；少个新功能，随意找个文件安置，但审核时要频繁查找跳来跳去；类似的情况比比皆是，也经常导致代码审核在大多数情况下会成为瞎眼流程。

我刚加盟跨国研发团队时，首先是产品架构培训，这部分主要是图和语言交流，接受起来相对容易。架构培训完毕后，当我计划信心满满的面对代码时，但看到数以百计的程序文件后，立马就蔫了。

一个特殊的培训救了我，这个培训叫程序映射清单，用于完成设计文档和程序之间的映射，当然里面要考虑的因素很多，我会在第6章给大家详细演示这个过程。目前，我们仅需要知道，通过这个映射清单，我们阅读任何一个函数代码时，可以很方便的将其放入整个框架设计中。本章侧重于约定某一个模块的程序文件长啥样，第6章架构设计部分侧重于如何组织这些模块的源文件。

一句话概括：我们读代码时，有方向感了。

◇◇◇

从架构文档到程序代码，首先面对的就是程序文件。

我们团队的嵌入式产品大多是用c语言实现的，c语言包含两类，头文件（.h）和源文件（.c）。头文件涉及c语言的一个基本概念，所有的函数、变量、结构等在使用前必须声明。

以前，我经常采用如下一些做法，如：

1.  感觉一个模块代码量不大，索性就将几个模块塞在一个文件中了；
2.  省略头文件，到处使用extern引用，或者用到什么函数时，就近写声明；
3.  模块和c文件干脆就是n：n的映射关系。  
    ……

稍微复杂的产品，其模块都非常多，一大堆模块堆在一起，容易混乱。此时，最常见的做法就是分层，将整个架构分为多层，每一层包含了若干个模块，上层模块通过层接口调用下层。

为了应对这种情况，每一层应该有自己的独立层声明头文件，其中会罗列一堆模块头文件，如下所示：

    #include “ai.h”
    #include “ao.h”
    #include “di.h”
    #include “do.h”
    ……
    

如果整个产品架构分为多层，一般情况下，层之间的接口是清晰的，但层内各模块之间或多或少会存在着各种耦合，如遥测模块越限生成遥信数据等等之类。此时，需要在层内增加一个私有的头文件，便于层内模块引用。借鉴C++语法习惯，我们项目组习惯将该头文件命名为“层名Private.h”，统一的名称不仅便于记忆，也便于后期代码级复用。该文件内部会罗列一堆私有头文件，如下所示：

    #include “aiPrivate.h”
    #include “aoPrivate.h”
    #include “diPrivate.h”
    #include “doPrivate.h”
    ……
    

因此，我们约定：**每个模块，都对应3个文件，如遥测模块对应ai.c，ai.h和aiPrivate.h（可省略）三个文件**。如果考虑架构设计时的模块分割和统一的数字字典，就可以完成设计文档到程序文件之间的映射。

3.2.2 头文件
---------

我们团队的编程规范约定：**头文件仅用于抽象和声明**。

熟悉C语言语法的小伙伴，都会理解#include的本质，实际上就是代码包含进去而已。因此，就有了很多程序技巧，如ucosII中通过不同的宏定义让同一套代码既可以是变量声明，又可以是变量定义；如lwip中结构体内容是通过#include包含进去的；……。这些技巧都带来了代码阅读负担，不方便审核，而且都有替代手段，因此我们果断的拒绝。

再次重申，头文件仅用于抽象和声明。

◇◇◇

开始审核一个模块头文件时，为了立即知道它属于那一层，属于哪一模块，有什么功能，我们约定了一个统一的文件头格式，如下示意：

    /***********************************************
    * 
    *   Copyright (C), 2015-2020, anotherWay. Co., Ltd.
    * 
    *   文件名称: ？？？.h
    *   版 本 号: ？.？
    *   生成日期: 2017-1-7
    *   作    者: 小马儿
    *   所属模块: ？？？？
    *   功    能: ？？？？？？
    * 
    *************************************************/
    

其中最关键的信息是该文件所属模块和功能描述，所属模块经常是指该模块所在的层。通过这两个信息，我们在审核一个头文件时就不会迷失了。

版本号主要用于代码级复用，注意该处的版本号不同于整个产品的版本号。很多模块代码有较强的复用性，可用于不同的产品，版本号便于其单独升级维护管理。如果不考虑复用，维持1.0默认值即可。

生成日期和作者经常被我们团队用来调侃，这段代码竟然15年都没修改过了啊；那段代码是某牛人写的啊，好厉害。不仅给无聊的编码工作增添了一丝乐趣，也会引导新人去阅读某些牛人的代码。

◇◇◇

在C语言中，容易出现头文件重复包含问题，也有多种解决策略。为了规避不同策略引起的冲突，我们团队约定所有的头文件增加统一的防止重复包含宏，且从项目角度保证文件不重名。如下所示（该处头文件为relay.h）。

    #ifndef __relay_H
    #define __relay_H
    ……
    #endif /* __relay_H */
    

第三部分是#include部分。不同于c文件中，头文件需要引用的内容较少，主要是一些数据类型和结构的声明，尽量去提炼汇总，并充分精简，便于后期代码级复用。

◇◇◇

C++是更好的C，因此有时用C++编译器编译C语言，可以发现一些隐藏的问题。在C++语言中，函数支持重载，因此编译链接的时候，文件名后会增加各种尾缀，这个机制会导致一些莫名其妙的异常。为了规避该问题，我们团队约定：**头文件统一增加如下描述**：

    #ifdef __cplusplus
    extern "C"{
    #endif
    
    ……
    
    #ifdef __cplusplus
    }
    #endif
    

然后就是头文件主体了，一般情况下是一堆结构定义和函数声明。

以前，我们喜欢在文件末尾增加修改记录，如下所示。后来统一使用了各种版本管理软件，版本变化的记录信息统一移入配置软件了。因此，该部分从代码中移除。

    /***************************************
    * 改动历史纪录：
    20015-12-9, 张三
    describe: 修改原因.
     
    20014-12-8, 李四
    describe: 初始创建.
    ****************************************/
    

◇◇◇

至此，一个头文件结构就被整体约定了，为了便于大家理解，整体展现如下（文件名为relay.h）：

    /***********************************************
    * 
    *   Copyright (C), 2015-2020, anotherWay. Co., Ltd.
    * 
    *   文件名称: relay.h
    *   版 本 号: 1.0
    *   生成日期: 2017-1-7
    *   作    者: 小马儿
    *   所属模块: api基础数据层
    *   功    能: 保护模块提供，并由api基础模块调用的接口函数
    * 
    *************************************************/
    
    #ifndef __relay_H
    #define __relay_H
    
    #include "typeDef.h"
    
    #ifdef __cplusplus
    extern "C"{
    #endif
    
    /* 初始化 */
    BOOL relInitModule(void);
    
    /* 投入定值后回调函数 */
    void relLaunchSettingHook(void);
    ……
    
    #ifdef __cplusplus
    }
    #endif
    
    #endif /* __relay_H */
    

3.2.3 源文件
---------

C文件主要是各模块实现文件，其整体结构类同于头文件。

第一部分也是功能描述，同头文件，不再赘述。

第二部分为#include文件引用。在具体实现时，头文件include特容易混乱，用到哪个了，立马include一个。这样的策略不仅不便于审核，更大的问题会导致模块之间产生强耦合关系。  
我们团队约定：**一个模块的C实现文件中包含的头文件仅允许有**：

1.  数据类型定义头文件（可省略）；
2.  下层引用头文件（可省略）；
3.  自己模块的声明头文件（一般不可省）；
4.  当前层私有引用头文件（可省略）。

增加这样的限制后，不仅审核成了教条化的操作，也不可能跨层次的随便调用其他模块接口，而打破架构约束，额外还便于后期代码级复用，因为头文件引用部分不会修改了。

第三部分为该模块对应的数据模型集中展现，统一安置，主要包含结构定义，变量，宏等信息。

依据我们团队的代码审核实践经验，统一数据模型安置，可以提升代码审核效率。一个经过熟练训练的程序员，在审核代码时，理解了数据结构，代码已经读个八八九九了。如看到一个变量，会去思考为何需要定义、目的是什么、初始化需要做什么、该变量的完整生命周期是什么等等之类。带着这些疑问去审核验证代码，更容易发现问题。

第四部分是文件内部函数的统一声明。

实践中，新人刚接触这一部分会感觉奇怪。我们写程序时，会经常发现需要增加一个子程序，将该函数置于前面，就可兼顾函数声明和实现了。这类代码审核的时候，审核者容易一开始就陷入细节，用不了多久就不知所云了。因此我们调整了函数顺序，先是外部函数，然后才是内部函数，审核者审核代码时，是从整体到局部，符合大脑的思维习惯。该要求的直接后果就是要求增加内部函数声明，我们习惯统一声明在文件前端。

不仅如此，我们约定：**文件内的全部函数排列必须遵从从整体到局部，从外部到内部的模式。内部函数强制为static函数，函数名前增加_前缀**。

项目组一开始约定，文件内静态函数前统一增加了s_前缀，但该约定不仅同静态变量冲突，而且函数名前增加s_前缀也怪怪的，然后大家就将s给去掉了。我需要强调的是，这种风格并不好，容易同一些系统函数冲突，但项目组已经习惯成自然了。大家侧重于理解这样做背后的逻辑，具体的策略大家可以自己定义。

从外部到内部，从整体到局部，说起来容易，做起来并不容易的。有些时候，内部函数也有先后关系，如某些函数是约定整个任务状态的，而有些函数是各状态具体应对的。没有统一的答案，但基本一条是符合人脑阅读习惯就好。

为了区分各层次代码，我们习惯在代码中插入分段符，如下所示：

    /******************************************/
    *                 数据模型                 */
    /******************************************/
    	……
    
    /******************************************/
    *                 对外接口函数             */
    /******************************************/
    	……
    

其中第二行中间全是空格而非tab，不仅便于段描述信息居中显示，也便于对齐。

除了前面这四部分约定，剩下的就是c文件的主体部分了，罗列内外函数的具体实现。C程序整体结构展示如下（文件名为relay.c）：

    /***********************************************
    * 
    *   Copyright (C), 2015-2020, anotherWay. Co., Ltd.
    * 
    *   文件名称: relay.c
    *   版 本 号: 1.0
    *   生成日期: 2017-1-7
    *   作    者: 小马儿
    *   所属模块: api基础数据层
    *   功    能: 保护模块提供，并由api基础模块调用的接口函数
    * 
    *************************************************/
    
    #include "relay.h"
    
    /******************************************/
    /*                  数据模型               */
    /******************************************/
    ……
    
    /******************************************/
    /*                内部函数集中声明          */
    /******************************************/
    ……
    
    /*****************************************/
    /*                 对外函数              */
    /*****************************************/
    ……
    
    /******************************************/
    /*                内部函数                */
    /******************************************/
    ……
    

◇◇◇

至此，我们约定了一个模块应该有哪些头文件和源文件，也约定了这些文件应该长什么样子。这类约定，可帮助我们完成从设计文档到代码细节的中间过渡，因此，统称为文件全局观。

[返回目录](https://blog.csdn.net/zhangmalong/article/details/103197670)